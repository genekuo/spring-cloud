# Migrate (Change to WiFi)
brew cask install ngrok

https://dashboard.ngrok.com/get-started

tunnel Authtoken: 1VgWebIoBTtTAutzKvELv6FDDCi_4sQAR5DdfrfQ23fuc2uHi

ngrok authtoken 1VgWebIoBTtTAutzKvELv6FDDCi_4sQAR5DdfrfQ23fuc2uHi

[self-signed certificate]
openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:2048 -keyout kubernetes/cert/tls.key -out kubernetes/cert/tls.crt -subject "/CN=minikube.me/O=minikube.me"


cat /etc/hosts

unset KUBECONFIG
minikube profile aepak8s
minikube config get profile

minikube start --memory=4096 --cpus=4 --kubernetes-version=v1.16.2 --vm-driver=virtualbox
minikube start --memory=4096 --cpus=4 --vm-driver=virtualbox
minikube start --memory=4096 --cpus=4

minikube addons list
minikube addons enable ingress
minikube addons enable metrics-server

eval $(minikube docker-env)

sudo bash -c "echo $(minikube ip) minikube.me | tee -a /etc/hosts"

./gradlew build && docker-compose build

kubectl delete namespace aepa-k8s
kubectl create namespace aepa-k8s
kubectl config set-context $(kubectl config current-context) --namespace=aepa-k8s

./kubernetes/scripts/deploy-dev-env.sh

[if connection refused]
minikube stop
minikube start
kubectl get pods -n aepa-k8s

kubectl get pods -o json | jq .items[].spec.containers[].image

HOST=minikube.me PORT=443 ./test-all.sh

ACCESS_TOKEN=$(curl -k https://writer:secret@minikube.me/oauth/token -d grant_type=password -d username=magnus -d password=password -s | jq .access_token -r)

curl -ks https://minikube.me/product-composite/2 -H "Authorization: Bearer $ACCESS_TOKEN" | jq .productId


[Auto-provision of certificates]
[Use the other at the end to install cert manager]
kubectl apply -f https://github.com/jetstack/cert-manager/releases/download/v0.12.0/cert-manager.yaml
kubectl wait --timeout=600s --for=condition=ready pod --all -n cert-manager

kubectl apply -f kubernetes/services/base/letsencrypt-issuer-staging.yaml

ngrok http https://minikube.me:443
NGROK_HOST=feaaae3f.ngrok.io

ACCESS_TOKEN=$(curl -k https://writer:secret@c9779861.ngrok.io/oauth/token -d grant_type=password -d username=magnus -d password=password -s | jq .access_token -r)
curl -ks https://c9779861.ngrok.io/product-composite/2 -H "Authorization: Bearer $ACCESS_TOKEN" | jq .productId

[separate console]
kubectl get cert --watch
kubectl apply -f kubernetes/services/base/ingress-edge-server-ngrok.yml

keytool -printcert -sslserver $NGROK_HOST:443 | grep -E "擁有者:|發出者:"

kubectl apply -f kubernetes/services/base/letsencrypt-issuer-prod.yaml
kubectl apply -f kubernetes/services/base/ingress-edge-server-ngrok.yml

HOST=$NGROK_HOST PORT=443 ./test-all.sh

https://feaaae3f.ngrok.io/actuator/health

kubectl delete namespace aepa-k8s

-----
kubectl run hello-world --image=karthequian/helloworld:latest --port=80
kubectl expose deployment hello-world --type=NodePort
minikube service hello-world -n aepa-k8s

sudo bash -c "echo $(minikube ip) minikube.local | tee -a /etc/hosts"

kubectl create -f kubernetes/hello-world/edge-server.yaml --save-config

 http://minikube.local

 http://362db99b.ngrok.io

 ngrok http minikube.local:80

 362db99b.ngrok.io

 kubectl apply -f kubernetes/hello-world/edge-server-ngrok.yaml

 http://362db99b.ngrok.io

kubectl create -f kubernetes/hello-world/rbac-config.yaml
?helm init --service-account tiller

kubectl apply --validate=false -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.12/deploy/manifests/00-crds.yaml

kubectl create namespace cert-manager

helm repo add jetstack https://charts.jetstack.io
helm repo update

helm install cert-manager --namespace cert-manager --version v0.12.0 jetstack/cert-manager
kubectl get pods --namespace cert-manager

kubectl get po -n cert-manager
kubectl logs -f cert-manager-5c47f46f57-vn64k -n cert-manager

kubectl apply -f kubernetes/hello-world/edge-server-ngrok.yaml

kubectl get pods --namespace cert-manager

cat <<EOF > test-resources.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: cert-manager-test
---
apiVersion: cert-manager.io/v1alpha2
kind: Issuer
metadata:
  name: test-selfsigned
  namespace: cert-manager-test
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1alpha2
kind: Certificate
metadata:
  name: selfsigned-cert
  namespace: cert-manager-test
spec:
  commonName: example.com
  secretName: selfsigned-cert-tls
  issuerRef:
    name: test-selfsigned
EOF

kubectl apply -f test-resources.yaml
kubectl describe certificate -n cert-manager-test
kubectl delete -f test-resources.yaml

kubectl apply -f kubernetes/hello-world/cluster-issuer.yaml

echo | openssl s_client -showcerts -servername feaaae3f.ngrok.io -connect feaaae3f.ngrok.io:443 2>/dev/null | openssl x509 -inform pem -noout -text

-----
eval $(minikube docker-env --unset)
minikube stop

docker-compose build

COMPOSE_FILE=docker-compose.yml
./test-all.sh start stop

docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)

docker rmi -f $(docker images -a -q)

COMPOSE_FILE=docker-compose-partitions.yml
./test-all.sh start stop

COMPOSE_FILE=docker-compose-kafka.yml
./test-all.sh start stop
